
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">project_pos_app/cmd/cron.go (0.0%)</option>
				
				<option value="file1">project_pos_app/config/config.go (0.0%)</option>
				
				<option value="file2">project_pos_app/controller/auth_controller/auth.go (0.0%)</option>
				
				<option value="file3">project_pos_app/controller/controller.go (0.0%)</option>
				
				<option value="file4">project_pos_app/controller/example_controller/example.go (0.0%)</option>
				
				<option value="file5">project_pos_app/controller/notif_controller/notif_controller.go (76.8%)</option>
				
				<option value="file6">project_pos_app/database/database.go (0.0%)</option>
				
				<option value="file7">project_pos_app/database/migration.go (0.0%)</option>
				
				<option value="file8">project_pos_app/database/redis.go (0.0%)</option>
				
				<option value="file9">project_pos_app/database/seeder.go (0.0%)</option>
				
				<option value="file10">project_pos_app/helper/logger.go (0.0%)</option>
				
				<option value="file11">project_pos_app/helper/mockDB.go (100.0%)</option>
				
				<option value="file12">project_pos_app/helper/response.go (50.0%)</option>
				
				<option value="file13">project_pos_app/infra/integration.go (0.0%)</option>
				
				<option value="file14">project_pos_app/main.go (0.0%)</option>
				
				<option value="file15">project_pos_app/model/notif.go (0.0%)</option>
				
				<option value="file16">project_pos_app/repository/auth_repository/auth.go (0.0%)</option>
				
				<option value="file17">project_pos_app/repository/example_repository/example.go (0.0%)</option>
				
				<option value="file18">project_pos_app/repository/notification/notif_repository.go (94.3%)</option>
				
				<option value="file19">project_pos_app/repository/notification/notif_repository_mock.go (0.0%)</option>
				
				<option value="file20">project_pos_app/repository/repository.go (0.0%)</option>
				
				<option value="file21">project_pos_app/router/router.go (0.0%)</option>
				
				<option value="file22">project_pos_app/service/auth_service/auth.go (0.0%)</option>
				
				<option value="file23">project_pos_app/service/example_service/example.go (0.0%)</option>
				
				<option value="file24">project_pos_app/service/notif_service/notif_service.go (69.6%)</option>
				
				<option value="file25">project_pos_app/service/notif_service/notif_service_mock.go (0.0%)</option>
				
				<option value="file26">project_pos_app/service/service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "log"
        "project_pos_app/controller"
        "project_pos_app/model"
        "time"

        "github.com/robfig/cron/v3"
)

func CronJob(ctx *controller.AllController) error <span class="cov0" title="0">{
        // Define a new cron scheduler
        c := cron.New(cron.WithLogger(cron.VerbosePrintfLogger(log.New(log.Writer(), "cron: ", log.LstdFlags))))

        // Schedule the task to run once a day at midnight
        _, err := c.AddFunc("*/10 * * * *", func() </span><span class="cov0" title="0">{
                log.Println("Starting daily report generation...")
                productName := "Nasi Goreng"
                data := model.NotifStock(productName)
                err := ctx.Notif.Service.Notif.CreateNotification(data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error generating report: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Report generation Alert %s completed successfully.", productName)
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start the cron scheduler
        <span class="cov0" title="0">c.Start()

        // Run a blocking loop to keep the cron job running
        go func() </span><span class="cov0" title="0">{
                select </span>{} // Prevent the function from exiting
        }()

        <span class="cov0" title="0">log.Printf("Cron job initialized and running. Current time: %v\n", time.Now())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "github.com/spf13/viper"
        "go.uber.org/zap"
)

type Config struct {
        AppName   string
        Port      string
        Debug     bool
        Migration bool
        Seeder    bool
        Database  Database
        Redis     Redis
}

type Database struct {
        DBName         string
        DBHost         string
        DBPort         string
        DBUser         string
        DBPassword     string
        DBConnection   int
        DBTimezone     string
        DBMaxIdleConst int
        DBMaxOpenConst int
        DBMaxIdleTime  int
        DBMaxLifeTime  int
}

type Redis struct {
        Url      string
        Password string
        Prefix   string
}

func SetConfig() (Config, error) <span class="cov0" title="0">{

        log := zap.Logger{}
        setEnv := viper.New()
        setEnv.SetConfigType("dotenv")
        viper.SetConfigFile(".env")

        viper.SetDefault("DBHost", "localhost")
        viper.SetDefault("DBPort", "5432")
        viper.SetDefault("DBUser", "postgres")
        viper.SetDefault("DBPassword", "admin")
        viper.SetDefault("DBName", "database")

        viper.AutomaticEnv()

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error reading config file: %s, using default values or environment variables", zap.Error(err))
        }</span>

        <span class="cov0" title="0">config := Config{
                AppName:   viper.GetString("APP_NAME"),
                Port:      viper.GetString("PORT"),
                Debug:     viper.GetBool("DEBUG"),
                Migration: viper.GetBool("AUTO_MIGRATE"),
                Seeder:    viper.GetBool("SEEDER"),

                Database: Database{
                        DBName:         viper.GetString("DB_NAME"),
                        DBHost:         viper.GetString("DB_HOST"),
                        DBPort:         viper.GetString("DB_PORT"),
                        DBUser:         viper.GetString("DB_USER"),
                        DBPassword:     viper.GetString("DB_PASSWORD"),
                        DBConnection:   viper.GetInt("DB_ConnectTimeOut"),
                        DBTimezone:     viper.GetString("DB_TIMEZONE"),
                        DBMaxIdleConst: viper.GetInt("DB_MAX_IDLE_CONNS"),
                        DBMaxOpenConst: viper.GetInt("DB_MAX_OPEN_CONNS"),
                        DBMaxIdleTime:  viper.GetInt("DB_MAX_IDLE_TIME"),
                        DBMaxLifeTime:  viper.GetInt("DB_MAX_LIFE_TIME"),
                },

                Redis: Redis{
                        Url:      viper.GetString("REDIS_URL"),
                        Password: viper.GetString("REDIS_PASSWORD"),
                        Prefix:   viper.GetString("REDIS_PREFIX"),
                },
        }

        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package authcontroller

import (
        "net/http"
        "project_pos_app/database"
        "project_pos_app/helper"
        "project_pos_app/model"
        "project_pos_app/service"

        "github.com/gin-gonic/gin"

        "go.uber.org/zap"
)

type AuthHadler struct {
        Service *service.AllService
        Log     *zap.Logger
        Cacher  *database.Cache
}

func NewUserHandler(service *service.AllService, log *zap.Logger, rdb *database.Cache) AuthHadler <span class="cov0" title="0">{
        return AuthHadler{
                Service: service,
                Log:     log,
                Cacher:  rdb,
        }
}</span>

func (auth *AuthHadler) Login(c *gin.Context) <span class="cov0" title="0">{
        login := model.Login{}
        ipAddress := c.ClientIP()

        err := c.ShouldBindJSON(&amp;login)
        if err != nil </span><span class="cov0" title="0">{
                auth.Log.Error("Invalid payload", zap.Error(err))
                helper.Responses(c, http.StatusInternalServerError, "Invalid Payload: "+err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">session, idKey, err := auth.Service.Auth.Login(&amp;login, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                auth.Log.Error("Failed to Login"+err.Error(), zap.Error(err))
                helper.Responses(c, http.StatusBadRequest, err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">token := session.Token
        IDKEY := idKey

        auth.Log.Info("Saving token to Redis", zap.String("IDKEY", IDKEY), zap.String("token", token))

        err = auth.Cacher.Set(IDKEY, token)
        if err != nil </span><span class="cov0" title="0">{
                helper.Responses(c, http.StatusInternalServerError, err.Error(), nil)
        }</span>

        <span class="cov0" title="0">helper.Responses(c, http.StatusOK, "successfully login", session)</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        authcontroller "project_pos_app/controller/auth_controller"
        examplecontroller "project_pos_app/controller/example_controller"
        notifcontroller "project_pos_app/controller/notif_controller"
        "project_pos_app/database"
        "project_pos_app/service"

        "go.uber.org/zap"
)

type AllController struct {
        Example examplecontroller.ExampleController
        Auth    authcontroller.AuthHadler
        Notif   notifcontroller.NotifController
}

func NewAllController(service *service.AllService, log *zap.Logger, cfg *database.Cache) AllController <span class="cov0" title="0">{
        return AllController{
                Example: examplecontroller.NewExampleController(service, log),
                Auth:    authcontroller.NewUserHandler(service, log, cfg),
                Notif:   notifcontroller.NewNotifController(service, log),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package examplecontroller

import (
        "project_pos_app/service"

        "go.uber.org/zap"
)

type ExampleController interface {
}

type exampleController struct {
        service *service.AllService
        log     *zap.Logger
}

func NewExampleController(service *service.AllService, log *zap.Logger) ExampleController <span class="cov0" title="0">{
        return &amp;exampleController{service, log}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package notifcontroller

import (
        "net/http"
        "project_pos_app/helper"
        "project_pos_app/model"
        "project_pos_app/service"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type NotifController struct {
        Service *service.AllService
        Log     *zap.Logger
}

func NewNotifController(service *service.AllService, log *zap.Logger) NotifController <span class="cov8" title="1">{
        return NotifController{
                Service: service,
                Log:     log,
        }
}</span>

func (c *NotifController) CreateNotifications(ctx *gin.Context) <span class="cov8" title="1">{
        var data model.Notification
        err := ctx.ShouldBindJSON(&amp;data)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Invalid payload", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Invalid Payload: "+err.Error(), nil)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">err = c.Service.Notif.CreateNotification(data)
        if err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to get all notifications", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to fetch notifications", nil)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">helper.Responses(ctx, http.StatusCreated, "Create notification successfully", nil)</span>
}

func (c *NotifController) GetAllNotifications(ctx *gin.Context) <span class="cov8" title="1">{
        status := ctx.Query("status")
        notifications, err := c.Service.Notif.GetAllNotifications(status)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Failed to get all notifications", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to fetch notifications", nil)
                ctx.Abort()
                return
        }</span>
        <span class="cov8" title="1">helper.Responses(ctx, http.StatusOK, "Get all notification successfully", notifications)</span>
}

func (c *NotifController) GetNotificationByID(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")
        notifID, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Invalid notification ID", zap.Error(err))
                helper.Responses(ctx, http.StatusBadRequest, "Invalid ID format", nil)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">notification, err := c.Service.Notif.GetNotificationByID(notifID)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Failed to get notification by ID", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to fetch notification", nil)
                ctx.Abort()
                return
        }</span>
        <span class="cov8" title="1">helper.Responses(ctx, http.StatusOK, "Notification retrieved successfully", notification)</span>
}

func (c *NotifController) UpdateNotification(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")
        notificationID, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Invalid notification ID", zap.Error(err))
                helper.Responses(ctx, http.StatusBadRequest, "Invalid ID format", nil)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">if err := c.Service.Notif.UpdateNotification(notificationID); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to update notification", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to update notification", nil)
                ctx.Abort()
                return
        }</span>
        <span class="cov8" title="1">helper.Responses(ctx, http.StatusOK, "Notification updated successfully", nil)</span>
}

func (c *NotifController) DeleteNotification(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")
        notificationID, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                c.Log.Error("Invalid notification ID", zap.Error(err))
                helper.Responses(ctx, http.StatusBadRequest, "Invalid ID format", nil)
                ctx.Abort()
                return
        }</span>

        <span class="cov8" title="1">if err := c.Service.Notif.DeleteNotification(notificationID); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to delete notification", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to delete notification", nil)
                ctx.Abort()
                return
        }</span>
        <span class="cov8" title="1">helper.Responses(ctx, http.StatusOK, "Notification deleted successfully", nil)</span>
}

func (c *NotifController) MarkAllNotificationsAsRead(ctx *gin.Context) <span class="cov8" title="1">{
        if err := c.Service.Notif.MarkAllNotificationsAsRead(); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to mark all notifications as read", zap.Error(err))
                helper.Responses(ctx, http.StatusInternalServerError, "Failed to mark all notifications as read", nil)
                ctx.Abort()
                return
        }</span>
        <span class="cov8" title="1">helper.Responses(ctx, http.StatusOK, "All notifications marked as read", nil)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "fmt"
        "log"
        "os"
        "project_pos_app/config"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func SetDatabase(cfg config.Config) (*gorm.DB, error) <span class="cov0" title="0">{

        logger := logger.New(
                log.New(os.Stdout, "\r\n", log.LstdFlags),
                logger.Config{
                        SlowThreshold:             time.Second,
                        Colorful:                  true,
                        IgnoreRecordNotFoundError: false,
                        LogLevel:                  logger.Info,
                },
        )

        db, err := gorm.Open(postgres.Open(
                fmt.Sprintf("host=%s port=%s user=%s dbname=%s sslmode=disable password=%s timezone=%s",
                        cfg.Database.DBHost, cfg.Database.DBPort, cfg.Database.DBUser, cfg.Database.DBName, cfg.Database.DBPassword, cfg.Database.DBTimezone)), &amp;gorm.Config{
                Logger: logger,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">if cfg.Migration </span><span class="cov0" title="0">{
                if err := Migration(db); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to make migration: " + err.Error())
                }</span>
        }

        <span class="cov0" title="0">if cfg.Seeder </span><span class="cov0" title="0">{
                if err := SeedAll(db); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to make seeder: " + err.Error())
                }</span>
        }

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package database

import (
        "fmt"
        "log"
        "project_pos_app/model"

        "gorm.io/gorm"
)

func Migration(db *gorm.DB) error <span class="cov0" title="0">{
        if err := db.Exec(`CREATE TABLE IF NOT EXISTS migrations (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) UNIQUE,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Define migrations
        <span class="cov0" title="0">allModel := []struct {
                name  string
                model interface{}
        }{
                // {"user", models.User{}},
                {"notification", model.Notification{}},
        }

        for _, migration := range allModel </span><span class="cov0" title="0">{
                var count int64
                err := db.Raw("SELECT COUNT(1) FROM migrations WHERE name = ?", migration.name).Scan(&amp;count).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check migration status for %s: %w", migration.name, err)
                }</span>

                <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("Migration '%s' already applied, skipping.", migration.name)
                        continue</span>
                }

                // Run migration
                <span class="cov0" title="0">if err := db.AutoMigrate(migration.model); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to migrate model %T: %w", migration.model, err)
                }</span>

                // Record migration as applied
                <span class="cov0" title="0">if err := db.Exec("INSERT INTO migrations (name) VALUES (?)", migration.name).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to record migration %s: %w", migration.name, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Migration '%s' applied successfully.", migration.name)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "context"
        "fmt"
        "project_pos_app/config"
        "time"

        "github.com/go-redis/redis/v8"
)

type Cache struct {
        rdb     *redis.Client
        expired time.Duration
        prefix  string
}

func newRedisClient(url, password string, dbIndex int) *redis.Client <span class="cov0" title="0">{
        return redis.NewClient(&amp;redis.Options{
                Addr:     url,
                Password: password,
                DB:       dbIndex,
        })
}</span>

func NewCache(cfg config.Config, expired int) Cache <span class="cov0" title="0">{
        return Cache{
                rdb:     newRedisClient(cfg.Redis.Url, cfg.Redis.Password, 0),
                expired: time.Duration(expired) * time.Second,
                prefix:  cfg.Redis.Prefix,
        }
}</span>

func (c *Cache) Push(name string, value []byte) error <span class="cov0" title="0">{
        return c.rdb.RPush(context.Background(), c.prefix+"_"+name, value).Err()
}</span>

func (c *Cache) Pop(name string) (string, error) <span class="cov0" title="0">{
        return c.rdb.LPop(context.Background(), c.prefix+"_"+name).Result()
}</span>

func (c *Cache) GetLength(name string) int64 <span class="cov0" title="0">{
        return c.rdb.LLen(context.Background(), c.prefix+"_"+name).Val()
}</span>

func (c *Cache) Set(name string, value string) error <span class="cov0" title="0">{
        return c.rdb.Set(context.Background(), c.prefix+"_"+name, value, c.expired).Err()
}</span>

func (c *Cache) SaveToken(name string, value string) error <span class="cov0" title="0">{
        return c.rdb.Set(context.Background(), c.prefix+"_"+name, value, 24*time.Hour).Err()
}</span>

func (c *Cache) Get(name string) (string, error) <span class="cov0" title="0">{
        return c.rdb.Get(context.Background(), c.prefix+"_"+name).Result()
}</span>

func (c *Cache) Delete(name string) error <span class="cov0" title="0">{
        return c.rdb.Del(context.Background(), c.prefix+"_"+name).Err()
}</span>

func (c *Cache) DeleteByKey(key string) error <span class="cov0" title="0">{
        return c.rdb.Del(context.Background(), key).Err()
}</span>

func (c *Cache) PrintKeys() <span class="cov0" title="0">{
        var cursor uint64
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, "", 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        fmt.Println("key", key)
                }</span>

                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }
}

func (c *Cache) GetKeys() []string <span class="cov0" title="0">{
        var cursor uint64
        var result []string
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, "", 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">result = append(result, keys...)

                if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func (c *Cache) GetKeysByPattern(pattern string) []string <span class="cov0" title="0">{
        var cursor uint64
        var result []string
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, pattern, 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">result = append(result, keys...)

                if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// Pub and Sub
func (c *Cache) Publish(channelName string, message string) error <span class="cov0" title="0">{
        return c.rdb.Publish(context.Background(), channelName, message).Err()
}</span>

func (c *Cache) Subcribe(channelName string) (*redis.Message, error) <span class="cov0" title="0">{
        subscriber := c.rdb.Subscribe(context.Background(), channelName)
        message, err := subscriber.ReceiveMessage(context.Background())
        return message, err
}</span>

func (c *Cache) GetClient() *redis.Client <span class="cov0" title="0">{
        return c.rdb
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "fmt"
        "log"
        "project_pos_app/model"
        "reflect"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

func SeedAll(db *gorm.DB) error <span class="cov0" title="0">{
        return db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                seeds := dataSeeds()
                for _, seed := range seeds </span><span class="cov0" title="0">{
                        var count int64
                        name := reflect.TypeOf(seed).String()

                        if err := tx.Model(seed).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Error checking data for table %s: %v", name, err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                                log.Printf("Seeding skipped for table %s, data already exists.", name)
                                continue</span>
                        }

                        <span class="cov0" title="0">err := tx.Clauses(clause.OnConflict{DoNothing: true}).Create(seed).Error
                        if err != nil </span><span class="cov0" title="0">{
                                errorMessage := err.Error()
                                log.Printf("%s seeder failed with error: %s", name, errorMessage)
                                continue</span>
                        }

                        <span class="cov0" title="0">resetSequence(tx, seed)</span>
                }

                <span class="cov0" title="0">log.Println("Seeding completed successfully.")
                return nil</span>
        })
}

// resetSequence resets the auto-increment sequence in case of conflict or error
func resetSequence(tx *gorm.DB, seed interface{}) <span class="cov0" title="0">{
        if tx.Dialector.Name() == "postgres" </span><span class="cov0" title="0">{
                tableName := getTableName(seed)
                if tableName != "" </span><span class="cov0" title="0">{
                        // Reset the sequence for PostgreSQL
                        query := fmt.Sprintf(`
                                SELECT setval(pg_get_serial_sequence('%s', 'id'), 
                                COALESCE((SELECT MAX(id) FROM %s), 1))`, tableName, tableName)
                        if err := tx.Exec(query).Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WARNING] Failed to reset sequence for table %s: %s", tableName, err)
                        }</span>
                }
        }
}

// getTableName returns the table name from the seed's struct
func getTableName(seed interface{}) string <span class="cov0" title="0">{
        seedType := reflect.TypeOf(seed)
        if seedType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                seedType = seedType.Elem()
        }</span>
        <span class="cov0" title="0">if seedType.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                return seedType.Name()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func dataSeeds() []interface{} <span class="cov0" title="0">{
        return []interface{}{
                model.NotificationSeed(),
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package helper

import (
        "log"
        "os"
        "project_pos_app/config"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

func InitLog(cfg config.Config) (*zap.Logger, error) <span class="cov0" title="0">{

        logLevel := zap.InfoLevel
        if cfg.Debug </span><span class="cov0" title="0">{
                logLevel = zap.DebugLevel
        }</span>

        <span class="cov0" title="0">encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "T",
                LevelKey:       "L",
                MessageKey:     "M",
                CallerKey:      "C",
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeDuration: zapcore.StringDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        file, err := os.Create("app.log")
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("Failed to open log file: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">writer := zapcore.AddSync(file)
        core := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                writer,
                logLevel,
        )
        logger := zap.New(core)
        logger.Info("Logger initialized successfully")

        return logger, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package helper

import (
        "project_pos_app/repository"
        "project_pos_app/repository/notification"
        notifservice "project_pos_app/service/notif_service"

        "github.com/DATA-DOG/go-sqlmock"
        "go.uber.org/zap"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func SetupTestDB() (*gorm.DB, sqlmock.Sqlmock) <span class="cov8" title="1">{
        db, mock, _ := sqlmock.New()
        dialector := postgres.New(postgres.Config{
                Conn:       db,
                DriverName: "postgres",
        })
        gormDB, _ := gorm.Open(dialector, &amp;gorm.Config{})
        return gormDB, mock
}</span>

func InitService() (*notification.MockDB, notifservice.NotifServiceInterface) <span class="cov8" title="1">{
        mockDB := new(notification.MockDB)
        MockRepo := &amp;repository.AllRepository{
                Notif: mockDB,
        }
        mockLogger := zap.NewNop()
        service := notifservice.NewNotifService(MockRepo, mockLogger)

        return mockDB, service
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package helper

import (
        "github.com/gin-gonic/gin"
)

type Response struct {
        Status     int
        Message    string
        Data       any `json:"data,omitempty"`
        Page       int `json:"page,omitempty"`
        Limit      int `json:"limit,omitempty"`
        TotalItems int `json:"total_items,omitempty"`
        TotalPages int `json:"total_pages,omitempty"`
}

func Responses(c *gin.Context, status int, massage string, data any) <span class="cov8" title="1">{
        c.JSON(status, Response{
                Status:  status,
                Message: massage,
                Data:    data,
        })
}</span>

func ResponsePagination(c *gin.Context, data interface{}, message string, page, limit, totalItems, totalPages, httpStatusCode int) <span class="cov0" title="0">{
        c.JSON(httpStatusCode, Response{
                Status:     httpStatusCode,
                Message:    message,
                Page:       page,
                Limit:      limit,
                TotalItems: totalItems,
                TotalPages: totalPages,
                Data:       data,
        })
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package infra

import (
        "project_pos_app/config"
        "project_pos_app/controller"
        "project_pos_app/database"
        "project_pos_app/helper"
        "project_pos_app/repository"
        "project_pos_app/service"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type IntegrationContext struct {
        Cfg   config.Config
        DB    *gorm.DB
        Log   *zap.Logger
        Ctl   controller.AllController
        Cache database.Cache
}

func NewIntegrateContext() (*IntegrationContext, error) <span class="cov0" title="0">{

        errorHandler := func(err error) (*IntegrationContext, error) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config, err := config.SetConfig()
        if err != nil </span><span class="cov0" title="0">{
                return errorHandler(err)
        }</span>

        <span class="cov0" title="0">log, err := helper.InitLog(config)
        if err != nil </span><span class="cov0" title="0">{
                return errorHandler(err)
        }</span>

        <span class="cov0" title="0">db, err := database.SetDatabase(config)
        if err != nil </span><span class="cov0" title="0">{
                return errorHandler(err)
        }</span>

        <span class="cov0" title="0">rdb := database.NewCache(config, 60*60)

        repo := repository.NewAllRepo(db, log)

        service := service.NewAllService(repo, log)

        handler := controller.NewAllController(service, log, &amp;rdb)

        return &amp;IntegrationContext{
                Cfg:   config,
                DB:    db,
                Log:   log,
                Ctl:   handler,
                Cache: rdb,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "project_pos_app/cmd"
        "project_pos_app/infra"
        "project_pos_app/router"
        "syscall"
        "time"
        // _ "project_pos_app/docs"
)

// @title App pos Team 2
// @version 1.0
// @description API for Point Of Sale
// @termsOfService http://example.com/terms/
// @contact.name API Support
// @contact.url http://example.com/support
// @contact.email support@example.com
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey Authentication
// @in header
// @name Authorization
// @securityDefinitions.apikey UserID
// @in header
// @name User-ID
// @securityDefinitions.apikey UserRole
// @in header
// @name User-Role

func main() <span class="cov0" title="0">{
        ctx, err := infra.NewIntegrateContext()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("can't init service context %w", err)
        }</span>

        <span class="cov0" title="0">r := router.NewRoutes(ctx)

        // init cron
        cmd.CronJob(&amp;ctx.Ctl)

        srv := &amp;http.Server{
                Addr:    ":8080",
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                // Start the server
                log.Printf("Server running on port 8080")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("listen: %s\n", err)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Println("Shutdown Server ...")

        // Create a timeout context for graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        // Attempt to gracefully shutdown the server
        if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server Shutdown:", err)
        }</span>

        // Catching context timeout
        <span class="cov0" title="0">select </span>{
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                log.Println("Timeout of 5 seconds.")</span>
        }

        <span class="cov0" title="0">log.Println("Server exiting")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import (
        "fmt"
        "time"
)

type Notification struct {
        ID        int       `gorm:"primaryKey" json:"id"` // Akan dikembalikan
        Title     string    `json:"title"`                // Akan dikembalikan
        Message   string    `json:"message"`              // Akan dikembalikan
        Status    string    `json:"status"`               // Akan dikembalikan
        CreatedAt time.Time `json:"-"`                    // Tidak akan dikembalikan
        UpdatedAt time.Time `json:"-"`                    // Tidak akan dikembalikan
}

func NotifStock(productName string) Notification <span class="cov0" title="0">{
        return Notification{
                Title:     "Stock Alert",
                Message:   fmt.Sprintf("products %s are out of stock. Please restock immediately.", productName),
                Status:    "new",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>

func NotificationSeed() []Notification <span class="cov0" title="0">{
        return []Notification{
                {
                        Title:     "Welcome",
                        Message:   "Thank you for joining our platform!",
                        Status:    "new",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Title:     "Discount Offer",
                        Message:   "Get 20% off on your next purchase.",
                        Status:    "new",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Title:     "System Update",
                        Message:   "Our system will undergo maintenance tonight from 12 AM to 3 AM.",
                        Status:    "readed",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Title:     "Stock Alert",
                        Message:   "One or more products are out of stock. Please restock immediately.",
                        Status:    "new",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package authrepository

import (
        "fmt"
        "project_pos_app/model"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "gorm.io/gorm"
)

type AuthRepoInterface interface {
        Login(login *model.Login, ipAddress string) (*model.Session, string, error)
}

type authRepo struct {
        DB  *gorm.DB
        Log *zap.Logger
}

func NewManagementVoucherRepo(db *gorm.DB, log *zap.Logger) AuthRepoInterface <span class="cov0" title="0">{
        return &amp;authRepo{DB: db, Log: log}
}</span>

func (a *authRepo) Login(login *model.Login, ipAddress string) (*model.Session, string, error) <span class="cov0" title="0">{

        token := uuid.New().String()

        user := model.User{}
        result := a.DB.Where("email = ? AND password = ?", login.Email, login.Password).First(&amp;user)

        if result.Error != nil </span><span class="cov0" title="0">{
                if result.Error == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("invalid email or password")
                }</span>
                <span class="cov0" title="0">return nil, "", result.Error</span>
        }

        <span class="cov0" title="0">session := model.Session{
                UserID:       user.ID,
                Token:        token,
                IpAddress:    ipAddress,
                LastActivity: time.Now(),
        }

        existingSession := model.Session{}
        err := a.DB.Where("user_id = ?", user.ID).First(&amp;existingSession).Error

        if err != nil &amp;&amp; err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                if err := a.DB.Create(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

        } else<span class="cov0" title="0"> {
                session.ID = existingSession.ID
                if err := a.DB.Save(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
        }

        <span class="cov0" title="0">return &amp;session, user.Name, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package examplerepository

import (
        "go.uber.org/zap"
        "gorm.io/gorm"
)

type ExampleRepository interface {
}

type exampleRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

func NewExampleRepo(DB *gorm.DB, Log *zap.Logger) ExampleRepository <span class="cov0" title="0">{
        return &amp;exampleRepository{DB, Log}
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package notification

import (
        "fmt"
        "project_pos_app/model"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type NotifRepoInterface interface {
        Create(data model.Notification) error
        GetAll(data *[]model.Notification, status string) error
        FindByID(id int) (model.Notification, error)
        Update(data *model.Notification, id int) error
        Delete(id int) error
        MarkAllAsRead() error
}

type notifRepo struct {
        DB  *gorm.DB
        Log *zap.Logger
}

func NewNotifRepo(db *gorm.DB, log *zap.Logger) NotifRepoInterface <span class="cov8" title="1">{
        return &amp;notifRepo{DB: db, Log: log}
}</span>

func (r *notifRepo) Create(data model.Notification) error <span class="cov8" title="1">{
        if err := r.DB.Create(&amp;data).Error; err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create notification")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *notifRepo) GetAll(data *[]model.Notification, status string) error <span class="cov8" title="1">{
        query := r.DB
        if status != "" </span><span class="cov8" title="1">{
                query = query.Where("status = ?", status)
        }</span>

        <span class="cov8" title="1">if err := query.Order("created_at desc").Find(&amp;data).Error; err != nil </span><span class="cov8" title="1">{
                r.Log.Error("Error GetnotifAll : ", zap.Error(err))
                return fmt.Errorf("error get list notif : %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *notifRepo) FindByID(id int) (model.Notification, error) <span class="cov8" title="1">{
        var data model.Notification
        err := r.DB.First(&amp;data, id).Error
        if err != nil </span><span class="cov8" title="1">{
                r.Log.Error("Failed get data", zap.Error(err))
                return model.Notification{}, fmt.Errorf("notification not found")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (r *notifRepo) Update(data *model.Notification, id int) error <span class="cov8" title="1">{
        var err error
        *data, err = r.FindByID(id)
        if err != nil </span><span class="cov8" title="1">{
                r.Log.Error("Error UpdateNotif : ", zap.Error(err))
                return fmt.Errorf("error update notif : %s", err.Error())
        }</span>

        <span class="cov8" title="1">data.Status = "readed"
        if err := r.DB.Save(&amp;data).Error; err != nil </span><span class="cov0" title="0">{
                r.Log.Error("Error UpdateNotif : ", zap.Error(err))
                return fmt.Errorf("error update notif : %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *notifRepo) Delete(id int) error <span class="cov8" title="1">{
        if err := r.DB.Delete(&amp;model.Notification{}, id).Error; err != nil </span><span class="cov8" title="1">{
                r.Log.Error("Error Delete Notif : ", zap.Error(err))
                return fmt.Errorf("error delete notif : %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *notifRepo) MarkAllAsRead() error <span class="cov8" title="1">{
        if err := r.DB.Model(&amp;model.Notification{}).Where("status = ?", "new").Update("status", "readed").Error; err != nil </span><span class="cov8" title="1">{
                r.Log.Error("Error Update Status All Notif : ", zap.Error(err))
                return fmt.Errorf("error update status all notif")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package notification

import (
        "project_pos_app/model"

        "github.com/stretchr/testify/mock"
        "gorm.io/gorm"
)

type MockDB struct {
        mock.Mock
}

func (m *MockDB) Where(query interface{}, args ...interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(query, args).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Order(value interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(value).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Find(dest interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(dest).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) First(dest interface{}, conds ...interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(dest, conds).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Save(value interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(value).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Model(value interface{}) *gorm.DB <span class="cov0" title="0">{
        return m.Called(value).Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Create(data model.Notification) error <span class="cov0" title="0">{
        args := m.Called(data)

        if err := args.Error(0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MockDB) GetAll(data *[]model.Notification, status string) error <span class="cov0" title="0">{
        args := m.Called()

        if notification := args.Get(0); notification != nil </span><span class="cov0" title="0">{
                *data = notification.([]model.Notification)
                return nil
        }</span>

        <span class="cov0" title="0">return args.Error(1)</span>
}

func (m *MockDB) FindByID(id int) (model.Notification, error) <span class="cov0" title="0">{
        args := m.Called(id)

        return args.Get(0).(model.Notification), args.Error(1)
}</span>

func (m *MockDB) Update(data *model.Notification, id int) error <span class="cov0" title="0">{
        args := m.Called(data, id)

        if args.Get(0) != nil </span><span class="cov0" title="0">{
                updatedNotif := args.Get(0).(*model.Notification)
                updatedNotif.Status = "reade"
                *data = *updatedNotif
        }</span>

        <span class="cov0" title="0">return args.Error(0)</span>
}

func (m *MockDB) Delete(id int) error <span class="cov0" title="0">{
        data, err := m.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">args := m.Called(data.ID)
        if notification := args.Get(0); notification != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return args.Error(1)</span>
}

func (m *MockDB) MarkAllAsRead() error <span class="cov0" title="0">{
        args := m.Called()

        if notification := args.Get(0); notification != nil </span><span class="cov0" title="0">{
                for _, v := range notification.([]model.Notification) </span><span class="cov0" title="0">{
                        if v.Status == "new" </span><span class="cov0" title="0">{
                                v.Status = "readed"
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        authrepository "project_pos_app/repository/auth_repository"
        examplerepository "project_pos_app/repository/example_repository"
        "project_pos_app/repository/notification"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type AllRepository struct {
        Example examplerepository.ExampleRepository
        Auth    authrepository.AuthRepoInterface
        Notif   notification.NotifRepoInterface
}

func NewAllRepo(DB *gorm.DB, Log *zap.Logger) *AllRepository <span class="cov0" title="0">{
        return &amp;AllRepository{
                Example: examplerepository.NewExampleRepo(DB, Log),
                Auth:    authrepository.NewManagementVoucherRepo(DB, Log),
                Notif:   notification.NewNotifRepo(DB, Log),
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package router

import (
        "project_pos_app/infra"

        "github.com/gin-gonic/gin"
)

func NewRoutes(ctx *infra.IntegrationContext) *gin.Engine <span class="cov0" title="0">{

        r := gin.Default()

        r.POST("/login", ctx.Ctl.Auth.Login)

        NotificationRoutes(r, ctx)
        return r
}</span>

func NotificationRoutes(r *gin.Engine, ctx *infra.IntegrationContext) <span class="cov0" title="0">{
        notifRoute := r.Group("/api")
        </span><span class="cov0" title="0">{
                notifRoute.POST("/notifications", ctx.Ctl.Notif.CreateNotifications)
                notifRoute.GET("/notifications", ctx.Ctl.Notif.GetAllNotifications)
                notifRoute.GET("/notifications/:id", ctx.Ctl.Notif.GetNotificationByID)
                notifRoute.PUT("/notifications/:id", ctx.Ctl.Notif.UpdateNotification)
                notifRoute.DELETE("/notifications/:id", ctx.Ctl.Notif.DeleteNotification)
                notifRoute.PUT("/notifications/mark-all-read", ctx.Ctl.Notif.MarkAllNotificationsAsRead)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package authservice

import (
        "project_pos_app/model"
        "project_pos_app/repository"

        "go.uber.org/zap"
)

type AuthService interface {
        Login(login *model.Login, ipAddress string) (*model.Session, string, error)
}

type authService struct {
        repo *repository.AllRepository
        log  *zap.Logger
}

func NewManagementVoucherService(repo *repository.AllRepository, log *zap.Logger) AuthService <span class="cov0" title="0">{
        return &amp;authService{repo, log}
}</span>

func (as *authService) Login(login *model.Login, ipAddress string) (*model.Session, string, error) <span class="cov0" title="0">{

        session, idKey, err := as.repo.Auth.Login(login, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">return session, idKey, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package exampleservice

import (
        "project_pos_app/repository"

        "go.uber.org/zap"
)

type ExampleService interface {
}

type exampleService struct {
        Repo *repository.AllRepository
        Log  *zap.Logger
}

func NewExampleService(Repo *repository.AllRepository, Log *zap.Logger) ExampleService <span class="cov0" title="0">{
        return &amp;exampleService{Repo, Log}
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package notifservice

import (
        "fmt"
        "project_pos_app/model"
        "project_pos_app/repository"
        "time"

        "go.uber.org/zap"
)

type NotifServiceInterface interface {
        CreateNotification(data model.Notification) error
        GetAllNotifications(status string) ([]model.Notification, error)
        GetNotificationByID(id int) (model.Notification, error)
        UpdateNotification(id int) error
        DeleteNotification(id int) error
        MarkAllNotificationsAsRead() error
}

type notifService struct {
        Repo *repository.AllRepository
        Log  *zap.Logger
}

func NewNotifService(repo *repository.AllRepository, log *zap.Logger) NotifServiceInterface <span class="cov8" title="1">{
        return &amp;notifService{
                Repo: repo,
                Log:  log,
        }
}</span>

func (s *notifService) CreateNotification(data model.Notification) error <span class="cov8" title="1">{
        now := time.Now()
        if data.Status == "" </span><span class="cov8" title="1">{
                data.Status = "new"
        }</span>
        <span class="cov8" title="1">data.CreatedAt = now
        data.UpdatedAt = now

        if data.Title == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("title should not none")
        }</span>

        <span class="cov8" title="1">return s.Repo.Notif.Create(data)</span>
}

func (s *notifService) GetAllNotifications(status string) ([]model.Notification, error) <span class="cov8" title="1">{
        var notifications []model.Notification
        if err := s.Repo.Notif.GetAll(&amp;notifications, status); err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to fetch notifications", zap.Error(err))
                return nil, fmt.Errorf("failed to fetch notifications: %w", err)
        }</span>
        <span class="cov8" title="1">return notifications, nil</span>
}

func (s *notifService) GetNotificationByID(id int) (model.Notification, error) <span class="cov8" title="1">{
        notification, err := s.Repo.Notif.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to fetch notification by ID", zap.Error(err))
                return model.Notification{}, err
        }</span>

        <span class="cov8" title="1">if notification.Title == "" </span><span class="cov8" title="1">{
                return model.Notification{}, fmt.Errorf("title is reqired")
        }</span>

        <span class="cov8" title="1">return notification, nil</span>
}

func (s *notifService) UpdateNotification(id int) error <span class="cov8" title="1">{
        notification, err := s.Repo.Notif.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to find notification for update", zap.Error(err))
                return fmt.Errorf("failed to find notification for update: %w", err)
        }</span>

        <span class="cov8" title="1">if notification.Title == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("title is reqired")
        }</span>

        <span class="cov8" title="1">notification.Status = "readed"
        if err := s.Repo.Notif.Update(&amp;notification, id); err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to update notification", zap.Error(err))
                return fmt.Errorf("failed to update notification: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *notifService) DeleteNotification(id int) error <span class="cov8" title="1">{
        notif, err := s.Repo.Notif.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to find notification for update", zap.Error(err))
                return fmt.Errorf("failed to find notification for update: %w", err)
        }</span>

        <span class="cov8" title="1">if notif.Title == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("title is reqired")
        }</span>

        <span class="cov8" title="1">if err := s.Repo.Notif.Delete(id); err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to delete notification", zap.Error(err))
                return fmt.Errorf("failed to delete notification: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *notifService) MarkAllNotificationsAsRead() error <span class="cov8" title="1">{
        if err := s.Repo.Notif.MarkAllAsRead(); err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to mark all notifications as read", zap.Error(err))
                return fmt.Errorf("failed to mark all notifications as read: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package notifservice

import (
        "project_pos_app/model"
        "project_pos_app/repository/notification"
        "time"

        "go.uber.org/zap"
)

// MockNotifServiceInterface mendefinisikan kontrak untuk mock service notifikasi
type MockNotifServiceInterface interface {
        CreateNotification(data model.Notification) error
        GetAllNotifications(status string) ([]model.Notification, error)
        GetNotificationByID(id int) (model.Notification, error)
        DeleteNotification(id int) error
        MarkAllNotificationsAsRead() error
        UpdateNotification(int) error
}

// MockNotifService implementasi mock service untuk notifikasi
type MockNotifService struct {
        Repo *notification.MockDB
        Log  *zap.Logger
}

// NewMockNotifService membuat instance baru dari mock service notifikasi
func NewMockNotifService(repo *notification.MockDB, log *zap.Logger) MockNotifServiceInterface <span class="cov0" title="0">{
        return &amp;MockNotifService{
                Repo: repo,
                Log:  log,
        }
}</span>

// CreateNotification membuat notifikasi baru
func (m *MockNotifService) CreateNotification(data model.Notification) error <span class="cov0" title="0">{
        m.Log.Info("Creating notification", zap.Any("notification", data))
        return m.Repo.Create(data)
}</span>

// GetAllNotifications mengambil semua notifikasi berdasarkan status
func (m *MockNotifService) GetAllNotifications(status string) ([]model.Notification, error) <span class="cov0" title="0">{
        now := time.Now()
        defaultData := []model.Notification{
                {
                        ID:        1,
                        Title:     "Notification 1",
                        Message:   "First test notification",
                        CreatedAt: now,
                        UpdatedAt: now,
                        Status:    status,
                },
                {
                        ID:        2,
                        Title:     "Notification 2",
                        Message:   "Second test notification",
                        CreatedAt: now,
                        UpdatedAt: now,
                        Status:    status,
                },
        }

        m.Log.Info("Fetching notifications", zap.String("status", status))

        err := m.Repo.GetAll(&amp;defaultData, status)
        if err != nil </span><span class="cov0" title="0">{
                m.Log.Error("Failed to get notifications", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">return defaultData, nil</span>
}

// GetNotificationByID mengambil notifikasi berdasarkan ID
func (m *MockNotifService) GetNotificationByID(id int) (model.Notification, error) <span class="cov0" title="0">{
        m.Log.Info("Fetching notification by ID", zap.Int("id", id))
        return m.Repo.FindByID(id)
}</span>

// UpdateNotification memperbarui notifikasi
func (m *MockNotifService) UpdateNotification(id int) error <span class="cov0" title="0">{
        data := &amp;model.Notification{
                ID:      1,
                Title:   "Testing",
                Message: "Test notification",
                Status:  "new",
        }
        m.Log.Info("Updating notification", zap.Int("id", id))
        return m.Repo.Update(data, id)
}</span>

// DeleteNotification menghapus notifikasi
func (m *MockNotifService) DeleteNotification(id int) error <span class="cov0" title="0">{
        m.Log.Info("Deleting notification", zap.Int("id", id))
        return m.Repo.Delete(id)
}</span>

// MarkAllNotificationsAsRead menandai semua notifikasi sebagai sudah dibaca
func (m *MockNotifService) MarkAllNotificationsAsRead() error <span class="cov0" title="0">{
        m.Log.Info("Marking all notifications as read")
        return m.Repo.MarkAllAsRead()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "project_pos_app/repository"
        authservice "project_pos_app/service/auth_service"
        exampleservice "project_pos_app/service/example_service"
        notifservice "project_pos_app/service/notif_service"

        "go.uber.org/zap"
)

type AllService struct {
        Example exampleservice.ExampleService
        Auth    authservice.AuthService
        Notif   notifservice.NotifServiceInterface
}

func NewAllService(repo *repository.AllRepository, log *zap.Logger) *AllService <span class="cov0" title="0">{
        return &amp;AllService{
                Example: exampleservice.NewExampleService(repo, log),
                Auth:    authservice.NewManagementVoucherService(repo, log),
                Notif:   notifservice.NewNotifService(repo, log),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
